// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: yield_metrics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestYieldMetric = `-- name: GetLatestYieldMetric :one
SELECT id, pool, chain, project, symbol, tvl_usd, apy_base, apy_reward, apy, reward_tokens, apy_pct_1d, apy_pct_7d, apy_pct_30d, stablecoin, il_risk, exposure, predictions, pool_meta, mu, sigma, count, outlier, underlying_tokens, il_7d, apy_base_7d, apy_mean_30d, volume_usd_1d, volume_usd_7d, apy_base_inception, created_at, updated_at FROM yield_metrics
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestYieldMetric(ctx context.Context) (YieldMetric, error) {
	row := q.db.QueryRow(ctx, getLatestYieldMetric)
	var i YieldMetric
	err := row.Scan(
		&i.ID,
		&i.Pool,
		&i.Chain,
		&i.Project,
		&i.Symbol,
		&i.TvlUsd,
		&i.ApyBase,
		&i.ApyReward,
		&i.Apy,
		&i.RewardTokens,
		&i.ApyPct1d,
		&i.ApyPct7d,
		&i.ApyPct30d,
		&i.Stablecoin,
		&i.IlRisk,
		&i.Exposure,
		&i.Predictions,
		&i.PoolMeta,
		&i.Mu,
		&i.Sigma,
		&i.Count,
		&i.Outlier,
		&i.UnderlyingTokens,
		&i.Il7d,
		&i.ApyBase7d,
		&i.ApyMean30d,
		&i.VolumeUsd1d,
		&i.VolumeUsd7d,
		&i.ApyBaseInception,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getYieldMetrics = `-- name: GetYieldMetrics :many
SELECT id, pool, chain, project, symbol, tvl_usd, apy_base, apy_reward, apy, reward_tokens, apy_pct_1d, apy_pct_7d, apy_pct_30d, stablecoin, il_risk, exposure, predictions, pool_meta, mu, sigma, count, outlier, underlying_tokens, il_7d, apy_base_7d, apy_mean_30d, volume_usd_1d, volume_usd_7d, apy_base_inception, created_at, updated_at FROM yield_metrics
WHERE pool = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetYieldMetricsParams struct {
	Pool   string `json:"pool"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetYieldMetrics(ctx context.Context, arg GetYieldMetricsParams) ([]YieldMetric, error) {
	rows, err := q.db.Query(ctx, getYieldMetrics, arg.Pool, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []YieldMetric{}
	for rows.Next() {
		var i YieldMetric
		if err := rows.Scan(
			&i.ID,
			&i.Pool,
			&i.Chain,
			&i.Project,
			&i.Symbol,
			&i.TvlUsd,
			&i.ApyBase,
			&i.ApyReward,
			&i.Apy,
			&i.RewardTokens,
			&i.ApyPct1d,
			&i.ApyPct7d,
			&i.ApyPct30d,
			&i.Stablecoin,
			&i.IlRisk,
			&i.Exposure,
			&i.Predictions,
			&i.PoolMeta,
			&i.Mu,
			&i.Sigma,
			&i.Count,
			&i.Outlier,
			&i.UnderlyingTokens,
			&i.Il7d,
			&i.ApyBase7d,
			&i.ApyMean30d,
			&i.VolumeUsd1d,
			&i.VolumeUsd7d,
			&i.ApyBaseInception,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYieldMetricsForChat = `-- name: GetYieldMetricsForChat :many
WITH latest_metrics AS (
    SELECT DISTINCT ON (pool) id, pool, chain, project, symbol, tvl_usd, apy_base, apy_reward, apy, reward_tokens, apy_pct_1d, apy_pct_7d, apy_pct_30d, stablecoin, il_risk, exposure, predictions, pool_meta, mu, sigma, count, outlier, underlying_tokens, il_7d, apy_base_7d, apy_mean_30d, volume_usd_1d, volume_usd_7d, apy_base_inception, created_at, updated_at
    FROM yield_metrics
    WHERE project = ANY($1::text[])
    ORDER BY pool, created_at DESC
)
SELECT 
    pool,
    chain,
    project,
    symbol,
    apy,
    apy_base as "apyBase",
    apy_reward as "apyReward",
    reward_tokens as "rewardTokens",
    underlying_tokens as "underlyingTokens"
FROM latest_metrics
ORDER BY symbol ASC
`

type GetYieldMetricsForChatRow struct {
	Pool             string         `json:"pool"`
	Chain            string         `json:"chain"`
	Project          string         `json:"project"`
	Symbol           string         `json:"symbol"`
	Apy              pgtype.Numeric `json:"apy"`
	ApyBase          pgtype.Numeric `json:"apyBase"`
	ApyReward        pgtype.Numeric `json:"apyReward"`
	RewardTokens     []string       `json:"rewardTokens"`
	UnderlyingTokens []string       `json:"underlyingTokens"`
}

func (q *Queries) GetYieldMetricsForChat(ctx context.Context, dollar_1 []string) ([]GetYieldMetricsForChatRow, error) {
	rows, err := q.db.Query(ctx, getYieldMetricsForChat, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetYieldMetricsForChatRow{}
	for rows.Next() {
		var i GetYieldMetricsForChatRow
		if err := rows.Scan(
			&i.Pool,
			&i.Chain,
			&i.Project,
			&i.Symbol,
			&i.Apy,
			&i.ApyBase,
			&i.ApyReward,
			&i.RewardTokens,
			&i.UnderlyingTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
